"""
    3^n-isogenies on elliptic curves in Hessian form and their Kummer lines
    ===============================================================================

    Let E be a curve in twisted Hessian form, i.e. 
    E: a * X^3 + Y^3 + Z^3 = d * X*Y*Z  

    The projection to the Kummer line is given by 
    (x : y : z) |-> (x : y + z) = : (x : u)

"""

from hessian_arithmetic_dim1 import *


class ThreeIsogenyKummer(SageObject):
    r"""
    Class for representing 3-isogenies of Hessian curves.

    Every such isogeny is of the form

    trafo -> Cube -> DFT -> Scale,

    where "trafo" is some special transformation that brings
    the kernel into the right form.

    We assume that the kernel is of the form (1 : alpha).
    """

    def __init__(self, point):
        r"""
        Constructs the 3-isogeny with kernel generated by `point`

        COST: 3 M + 2 S
        """
        self._kernel = point
        x0, u0 = point.xu()
        assert x0 != 0
        self._domain = point._parent

        a , d = point._parent._a, point._parent._d
        # recall: alpha = - u0 / x0, alpha^3 = a
        assert u0**3 == - x0**3 * a
        dx0 = d * x0 # 1 M_d
        self._aux = dx0 + u0

        a1 = self._aux**3  # 1 M + 1 S
        d1 = dx0 - u0 - u0
        # isomorphic to the domain
        H_iso = EllipticCurveHessianForm(d1, a=a1).kummer()
        self._intermediate = H_iso

        self._codomain = H_iso._special_isogeny_neighbour() # 1 M + 1 S
        self._codomain._isogeny_neighbour = H_iso

    def _repr_(self):
        """
        String representation.
        """
        s = "3-Isogeny \n"
        s += " From: %s \n" % self._domain
        s += " To: %s \n" % self._codomain
        s += " Kernel:  %s " % self._kernel
        return s

    def __call__(self, P):
        r"""
        Evaluate the isogeny `self` in the point `P`.
        """
        x0, u0 = self._kernel.xu()
        P = P._scale(-u0, x0) # 2 M
        P = P._DFT()
        P = P._scale(1, self._aux) # 1 M
        P = self._intermediate(P.xu())
        P = P.evaluate_phi_1()
        assert P == self._codomain(P.xu()) # sanity check

        return P

class Three_N_IsogenyKummer(SageObject):
    r"""
    Class for representing 3^n-isogenies of Hessian curves.

    Every such isogeny is represented as a chain of 3-isogenies

    EXAMPLES:

    We construct an elliptic curve with full 3^10-torsion over Fp2, where
    Fp2 contains a primitive 3rd root of unity omega::

        sage: p = 8*3^10 - 1
        sage: F1 = GF(p)
        sage: R.<x> = F1[]
        sage: Fp.<a> = GF(p^2, modulus=x^2+x+1)
        sage: omega = a
        sage: E = EllipticCurve(Fp, [1,0])
        sage: P,Q = E.torsion_basis(3^10)
        sage: P3 = 3^9*P
        sage: Q3 = 3^9*Q

    The 3-torsion basis (P3,Q3) determines the isomorphism to the Hessian curve.
    The point Q3 is sent to (0 : -alpha : 1)::

        sage: H = EllipticCurveHessianForm(E, basis=[P3,Q3])
        sage: H.map_point(Q3)
        (0 : 12336*a + 460055 : 24672*a + 12336)
        sage: Hb = H.kummer()

    We can compute 3^9 - isogenies with kernel  3*(P + k*Q) for arbitrary values k::

        sage: k = ZZ.random_element(3^9)
        sage: kernel = P + k*Q
        sage: P_H = H.map_point(P)
        sage: P_K = Hb(P_H)
        sage: Phi = Three_N_IsogenyKummer(P_K, 9); Phi #random
        3^9 - Isogeny
         From : Kummer Line of Elliptic Curve in Hessian form defined by x^3 + y^3 + 124259*x*y*z + z^3 over Finite Field in a of size 472391^2
         To : Kummer Line of Elliptic Curve in Hessian form defined by (-231227*a + 112106)*x^3 + y^3 + (91506*a - 73354)*x*y*z + z^3 over Finite Field in a of size 472391^2

    """

    def __init__(self, point, n):
        r"""
        Constructs the 3^n-isogeny with kernel generated by `3*point`

        COST: 3 M + 2 S
        """
        self._point = point
        self._chain = []
        self._n = n
        for k in range(n):
            # multiply by 3^(n-k)
            P3 = point
            for i in range(n-k):
                P3 = P3.xTRPL()
            x0, u0 = P3.xu()
            assert u0**3 == - x0**3 * point._parent._a #sanity check, delete
            phi_k = ThreeIsogenyKummer(P3)
            self._chain.append(phi_k)
            point = phi_k(point)

    def _repr_(self):
        """
        String representation.
        """
        s = "3^%s - Isogeny \n" % self._n
        s += " From : %s \n" % self._chain[0]._domain
        s += " To : %s" % self._chain[-1]._codomain
        return s

    def __call__(self, P):
        r"""
        Evaluate the isogeny `self` in the point `P`.
        """
        for phi_k in self._chain:
            P = phi_k(P)
        return P